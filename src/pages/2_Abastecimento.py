# pages/2_Abastecimento.py
import streamlit as st
import pandas as pd
from datetime import datetime
import config # Import config

st.set_page_config(layout="wide")

# --- Check Login and Role ---
# ... (keep existing checks) ...
if not st.session_state.get('logged_in'):
    st.error("Por favor, faça o login para acessar esta página.")
    st.stop()
if st.session_state.get('role') != 'Usuario':
    st.error("Apenas usuários com perfil 'Usuario' podem acessar esta página.")
    st.stop()
if not st.session_state.get('data_loaded') or not st.session_state.get('db_manager'):
    st.warning("Os dados ainda estão sendo carregados ou o gerenciador não foi inicializado.")
    st.stop()


manager = st.session_state.db_manager
username = st.session_state.get('username')
nome_completo = st.session_state.get('nome_completo')

# --- Page Title ---
st.markdown("#### ✅ Registrar Novo Abastecimento")
st.write(f"Registrando como: **{nome_completo}**")
st.divider()

# --- Get Client Options from Local Cache (FILTERED) ---
# ... (keep existing client fetching) ...
assigned_client_names = manager.get_assigned_clients_local(username)
if not assigned_client_names:
    st.warning("⚠️ Você não está atribuído a nenhum cliente.")
    client_options_display = ["Selecione..."]
else:
     client_options_display = ["Selecione..."] + sorted(assigned_client_names)

# --- Data Entry Form ---
with st.form("abastecimento_form", clear_on_submit=True):
    st.subheader("Detalhes do Registro")

    col1, col2 = st.columns(2)
    with col1:
        data_reg = st.date_input("Data do Registro", value=datetime.now().date(), key="form_data_reg")
        cliente_selecionado = st.selectbox(
            "Cliente Atribuído",
            options=client_options_display,
            key="form_cliente",
            disabled=(not assigned_client_names)
        )
        dimensao = st.selectbox(
             "Dimensão / Critério",
             # Use keys from CRITERIA_COLORS for consistency
             options=["Selecione..."] + list(config.CRITERIA_COLORS.keys()),
             key="form_dimensao"
        )
    with col2:
        quantidade = st.number_input("Quantidade (Links/Documentos)", min_value=1, value=1, step=1, key="form_qtd")
        # --- UPDATED: Use config.VALID_STATUSES, default to 'Novo' or 'Enviado' ---
        status_inicial = st.selectbox(
             "Status Inicial",
             options=[s for s in config.VALID_STATUSES if s not in ['Validado', 'Inválido']], # User shouldn't set these initially
             index=0, # Default to the first option ('Novo')
             key="form_status"
        )

    links_docs = st.text_area(
        "Links Abastecidos ou Nome dos Documentos (UM POR LINHA)", # Updated instruction
        height=150,
        key="form_links",
        help="Insira um link ou nome de documento por linha. Cada linha será um registro separado."
    )

    # --- Submit Button ---
    submitted = st.form_submit_button("💾 Adicionar Registro(s) Localmente")

    if submitted:
        # --- Validation ---
        errors = []
        if not assigned_client_names: errors.append("Nenhum cliente atribuído para registrar.")
        if cliente_selecionado == "Selecione...": errors.append("Selecione um cliente.")
        if dimensao == "Selecione...": errors.append("Selecione a dimensão/critério.")
        if not links_docs.strip(): errors.append("Insira pelo menos um link ou nome de documento.")

        if errors:
             for error in errors: st.error(error)
        else:
            # Process entries (one per line)
            items = [item.strip() for item in links_docs.strip().split('\n') if item.strip()]
            num_added = 0
            num_failed = 0

            for item_desc in items:
                # Ensure all columns from config.DOCS_COLS are present
                doc_data = {
                    "id": None, # Generated by add_documento_local
                    "colaborador_username": username,
                    "cliente_nome": cliente_selecionado,
                    "data_registro": data_reg.isoformat() if data_reg else None,
                    "dimensao_criterio": dimensao,
                    "link_ou_documento": item_desc,
                    "quantidade": 1, # One per line item
                    "status": status_inicial,
                    "data_envio_original": None,
                    # NEW Validation columns default to None/Null
                    "data_validacao": None,             
                    "validado_por": None,               
                    "observacoes_validacao": None,      
                }
                # Ensure any other columns in DOCS_COLS are added here with None or default

                add_success = manager.add_documento_local(doc_data)
                if add_success:
                     num_added += 1
                else:
                     num_failed += 1

            if num_added > 0:
                st.success(f"{num_added} registro(s) adicionado(s) com sucesso à sua sessão local.")
                st.info("Use a opção 'Salvar Selecionados' abaixo ou na barra lateral para enviar os dados.")
            if num_failed > 0:
                st.warning(f"{num_failed} registro(s) falharam ao ser adicionados localmente.")
            # Form clears automatically

# --- Display Recent Local Entries for this User ---
# ... (Keep existing logic for displaying unsynced docs and saving selected) ...
st.divider()
st.subheader("Registros Locais Pendentes de Envio")

unsynced_docs = manager.get_unsynced_documents_local(username)

if 'editor_key_counter' not in st.session_state: st.session_state.editor_key_counter = 0
editor_key = f"data_editor_{st.session_state.editor_key_counter}"

if unsynced_docs:
     df_unsynced = pd.DataFrame([dict(row) for row in unsynced_docs])
     cols_to_show = ['data_registro', 'cliente_nome', 'dimensao_criterio', 'link_ou_documento', 'status', 'id']
     df_display = df_unsynced[[col for col in cols_to_show if col in df_unsynced.columns]].copy()
     df_display.insert(0, "Selecionar", False)

     column_config_unsync = {
         "Selecionar": st.column_config.CheckboxColumn("Selecionar", required=True),
         "id": st.column_config.TextColumn("ID", disabled=True),
         "data_registro": st.column_config.DateColumn("Data Reg.", format="DD/MM/YYYY", disabled=True),
         "cliente_nome": st.column_config.TextColumn("Cliente", disabled=True),
         "dimensao_criterio": st.column_config.TextColumn("Critério", disabled=True),
         "link_ou_documento": st.column_config.TextColumn("Link/Doc", width="large", disabled=True),
         "status": st.column_config.TextColumn("Status", disabled=True),
     }
     final_column_config_unsync = {k:v for k,v in column_config_unsync.items() if k in df_display.columns}

     st.info("Marque os registros que deseja enviar para a planilha e clique em 'Salvar Selecionados'.")
     edited_df_unsync = st.data_editor(
         df_display,
         column_config=final_column_config_unsync,
         key=editor_key,
         hide_index=True,
         use_container_width=True,
         num_rows="dynamic"
     )

     selected_rows_unsync = edited_df_unsync[edited_df_unsync["Selecionar"] == True]
     selected_ids_unsync = selected_rows_unsync["id"].tolist() if not selected_rows_unsync.empty else []

     st.markdown(f"**{len(selected_ids_unsync)}** registro(s) selecionado(s).")

     st.divider()
     if st.button("💾 Salvar Selecionados na Planilha", disabled=(not selected_ids_unsync)):
         if selected_ids_unsync:
             with st.spinner("Enviando dados selecionados para a planilha..."):
                 # Use the APPEND method for selected items
                 save_success = manager.save_selected_docs_to_sheets(username, selected_ids_unsync)
             if save_success:
                 st.success(f"{len(selected_ids_unsync)} registros selecionados foram enviados com sucesso!")
                 st.toast("Dados sincronizados!")
                 st.session_state.editor_key_counter += 1
                 st.rerun()
             else:
                 st.error("Falha ao salvar os registros selecionados na planilha.")
                 st.toast("Erro ao sincronizar.")
         else:
             st.warning("Nenhum registro foi selecionado para salvar.")

elif st.session_state.get('unsaved_changes'):
      st.warning("Você possui alterações locais, mas não foi possível exibi-las. Tente recarregar.")
else:
      st.info("Nenhum registro local pendente de envio.")

# --- Final check for unsaved changes ---
final_check_unsaved = manager.get_unsynced_documents_local(username)
st.session_state['unsaved_changes'] = bool(final_check_unsaved)