# pages/2_Abastecimento.py
import streamlit as st
import pandas as pd
from datetime import datetime
import config # Import config

st.set_page_config(layout="wide")

# --- Check Login and Role ---
if not st.session_state.get('logged_in'):
    st.error("Por favor, fa√ßa o login para acessar esta p√°gina.")
    st.stop()
if st.session_state.get('role') != 'Usuario':
    st.error("Apenas usu√°rios com perfil 'Usuario' podem acessar esta p√°gina.")
    st.stop()
if not st.session_state.get('data_loaded') or not st.session_state.get('db_manager'):
    st.warning("Os dados ainda est√£o sendo carregados ou o gerenciador n√£o foi inicializado.")
    st.stop()

manager = st.session_state.db_manager
username = st.session_state.get('username')
nome_completo = st.session_state.get('nome_completo')

# --- Page Title ---
st.markdown("#### ‚úÖ Registrar Novo Abastecimento")
st.write(f"Registrando como: **{nome_completo}**")
st.divider()

# --- Get Client Options from Local Cache (FILTERED) ---
assigned_client_names = manager.get_assigned_clients_local(username)

if not assigned_client_names:
    st.warning("‚ö†Ô∏è Voc√™ n√£o est√° atribu√≠do a nenhum cliente. Pe√ßa ao administrador para atribuir clientes a voc√™.")
    client_options_display = ["Selecione..."]
else:
     # Display only assigned clients
     client_options_display = ["Selecione..."] + sorted(assigned_client_names)
     
     
# --- Data Entry Form ---
with st.form("abastecimento_form", clear_on_submit=True):
    st.subheader("Detalhes do Registro")

    col1, col2 = st.columns(2)
    with col1:
        data_reg = st.date_input("Data do Registro", value=datetime.now().date(), key="form_data_reg")
        cliente_selecionado = st.selectbox(
            "Cliente Atribu√≠do", # Label changed slightly
            options=client_options_display,
            key="form_cliente",
            disabled=(not assigned_client_names) # Disable if no clients assigned
        )
        dimensao = st.selectbox(
             "Dimens√£o / Crit√©rio",
             options=["Selecione...", "Essencial", "Obrigat√≥rio", "Recomendado"], # Match config.CRITERIA_COLORS keys
             key="form_dimensao"
        )
    with col2:
        quantidade = st.number_input("Quantidade (Links/Documentos)", min_value=1, value=1, step=1, key="form_qtd")
        status_inicial = st.selectbox(
             "Status Inicial",
             options=["Novo", "Enviado", "Validado", "Pendente"], # Define available statuses
             index=0, # Default to 'Novo'
             key="form_status"
        )

    links_docs = st.text_area(
        "Links Abastecidos ou Nome dos Documentos (separados por v√≠rgula)",
        height=150,
        key="form_links"
    )

    # --- Submit Button ---
    submitted = st.form_submit_button("üíæ Adicionar Registro(s) Localmente")

    if submitted:
        # --- Validation ---
        errors = []
        if not assigned_client_names: errors.append("Nenhum cliente atribu√≠do para registrar.")
        if cliente_selecionado == "Selecione...": errors.append("Selecione um cliente.")
        if dimensao == "Selecione...": errors.append("Selecione a dimens√£o/crit√©rio.")
        if not links_docs.strip(): errors.append("Insira pelo menos um link ou nome de documento.")
        
        if errors:
             for error in errors: st.error(error)
        else:
            # Process entries (one per line in the text area)
            items = [item.strip() for item in links_docs.strip().split('\n') if item.strip()]
            num_added = 0
            num_failed = 0

            for item_desc in items:
                doc_data = {
                    # From config.DOCS_COLS - Add ALL columns expected
                    "id": None, # Will be generated by add_documento_local
                    "colaborador_username": username,
                    "cliente_nome": cliente_selecionado,
                    "data_registro": data_reg.isoformat() if data_reg else None,
                    "dimensao_criterio": dimensao,
                    "link_ou_documento": item_desc,
                    "quantidade": 1, # Assume 1 per line item, or adjust based on 'quantidade' field?
                    "status": status_inicial,
                    "data_envio_original": None, # Populate if relevant
                    # Add other columns from DOCS_COLS as None or with default values
                }
                # Use the general 'quantidade' field if it applies to ALL items equally?
                doc_data["quantidade"] = quantidade

                add_success = manager.add_documento_local(doc_data)
                if add_success:
                     num_added += 1
                else:
                     num_failed += 1

            if num_added > 0:
                st.success(f"{num_added} registro(s) adicionado(s) com sucesso √† sua sess√£o local.")
                st.info("Clique em 'Salvar Altera√ß√µes na Planilha' na barra lateral para enviar os dados.")
            if num_failed > 0:
                st.warning(f"{num_failed} registro(s) falharam ao ser adicionados localmente.")
            # Form clears automatically due to clear_on_submit=True


# --- Display Recent Local Entries for this User ---
st.divider()
st.subheader("Registros Locais Pendentes de Envio")

unsynced_docs = manager.get_unsynced_documents_local(username)

# Store data editor state to track selections
if 'editor_key_counter' not in st.session_state: st.session_state.editor_key_counter = 0

editor_key = f"data_editor_{st.session_state.editor_key_counter}"

if unsynced_docs:
     df_unsynced = pd.DataFrame([dict(row) for row in unsynced_docs])

     # Define quais colunas mostrar e quais desabilitar
     cols_to_show = ['data_registro', 'cliente_nome', 'dimensao_criterio', 'link_ou_documento', 'quantidade', 'status', 'id']
     cols_display_map = {col: col for col in cols_to_show if col in df_unsynced.columns} # Keep original names for now

     # --- Preparar DataFrame para data_editor ---
     df_display = df_unsynced[list(cols_display_map.keys())].copy() # Pega s√≥ as colunas desejadas

     # Adiciona coluna de sele√ß√£o no IN√çCIO
     df_display.insert(0, "Selecionar", False)

     # --- Configura√ß√£o das Colunas do Editor ---
     column_config = {
         "Selecionar": st.column_config.CheckboxColumn("Selecionar", required=True),
         "id": st.column_config.TextColumn("ID", disabled=True), # Mostrar ID mas n√£o editar
         "data_registro": st.column_config.DateColumn("Data Reg.", format="DD/MM/YYYY", disabled=True),
         "cliente_nome": st.column_config.TextColumn("Cliente", disabled=True),
         "dimensao_criterio": st.column_config.TextColumn("Crit√©rio", disabled=True),
         "link_ou_documento": st.column_config.TextColumn("Link/Doc", width="large", disabled=True),
         "quantidade": st.column_config.NumberColumn("Qtd.", disabled=True),
         "status": st.column_config.TextColumn("Status", disabled=True),
         # Configurar outras colunas se mostradas
     }

     # Garante que s√≥ configure colunas que existem no df_display
     final_column_config = {k:v for k,v in column_config.items() if k in df_display.columns}

     st.info("Marque os registros que deseja enviar para a planilha e clique em 'Salvar Selecionados'.")
     edited_df = st.data_editor(
         df_display,
         column_config=final_column_config,
         key=editor_key, # Usa chave din√¢mica
         hide_index=True,
         use_container_width=True,
         num_rows="dynamic" # Permite que a altura se ajuste
     )

     # Filtrar linhas selecionadas
     selected_rows = edited_df[edited_df["Selecionar"] == True]
     selected_ids = selected_rows["id"].tolist() if not selected_rows.empty else []

     st.markdown(f"**{len(selected_ids)}** registro(s) selecionado(s).")

     # --- Bot√£o de Salvar SELECIONADOS ---
     st.divider()
     if st.button("üíæ Salvar Selecionados na Planilha", disabled=(not selected_ids)):
         if selected_ids:
             with st.spinner("Enviando dados selecionados para a planilha..."):
                 save_success = manager.save_selected_docs_to_sheets(username, selected_ids)

             if save_success:
                 st.success(f"{len(selected_ids)} registros selecionados foram enviados com sucesso!")
                 st.toast("Dados sincronizados!")
                 # Incrementa a chave para for√ßar rerender do data_editor
                 st.session_state.editor_key_counter += 1
                 st.rerun() # Rerun para atualizar a tabela e o estado 'unsaved_changes'
             else:
                 st.error("Falha ao salvar os registros selecionados na planilha.")
                 st.toast("Erro ao sincronizar.")
         else:
             st.warning("Nenhum registro foi selecionado para salvar.")

elif st.session_state.get('unsaved_changes'):
      # Este caso pode ocorrer se algo foi adicionado mas houve erro ao buscar
      st.warning("Voc√™ possui altera√ß√µes locais, mas n√£o foi poss√≠vel exibi-las. Tente recarregar.")
else:
      st.info("Nenhum registro local pendente de envio.")

# --- Atualizar display de 'unsaved_changes' (Bot√£o/aviso na sidebar) ---
# Verifica novamente AP√ìS a renderiza√ß√£o da tabela e poss√≠vel save
final_check_unsaved = manager.get_unsynced_documents_local(username)
if final_check_unsaved:
     st.session_state['unsaved_changes'] = True
else:
     st.session_state['unsaved_changes'] = False